A docker image for kubernetes based on gcr.io/google_containers/zookeeper-install:0.1.

With the gcr image its entry point is to install zookeeper, and its designed to be an initContainer for a pod.  Its part of a initContainer chain, that does an install of zookeeper, and then does a bootstrap using peer-finder for petsets/statefulsets.  eg something like this: https://github.com/onyx-platform/docker-zookeeper/blob/master/zookeeper.petset.yaml. With the initContainer method, for each pod created in the statefulsets definition, it does a wget to download and install zookeeper. Then peer-finder is run as a second initContainer before the final container is run. So three containers are run within the pod space, one after another. This can be error prone as the wget may not work, and you cannot version control the image deployed. Thus building the image at pod creation time is slow, error prone, and inefficient, and is not the normal way of deploying microservices. 

What if you want to build an image based on the functionality above, and use it with statefulsets? This is what this Dockerfile does. Thus you would use docker build to create your image, and then specify the image in you statefulsets config rather than the initContainer method. If you use a docker container in the normal way, peer-finder can be run prior to zookeeper server, as part of the container entry point, and there is no need to run 2 containers before the target container.

